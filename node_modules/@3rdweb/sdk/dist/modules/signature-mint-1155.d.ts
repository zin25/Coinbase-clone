import { SignatureMint1155 } from "@3rdweb/contracts";
import { BigNumber, BigNumberish } from "@ethersproject/bignumber";
import { TransactionReceipt } from "@ethersproject/providers";
import { BytesLike } from "ethers";
import { ModuleType, Role } from "../common";
import { NFTMetadata } from "../common/nft";
import { ModuleWithRoles } from "../core/module";
import { MetadataURIOrObject } from "../core/types";
import { ITransferable } from "../interfaces/contracts/ITransferable";
import { Erc1155SignaturePayload, NewErc1155SignaturePayload } from "../types/signature-minting";
export interface TokenERC1155Metadata {
    supply: BigNumber;
    metadata: NFTMetadata;
    quantityOwnedByAddress: BigNumber;
}
/**
 * @beta
 */
export interface TokenERC1155CreateAndMintArgs {
    metadata: MetadataURIOrObject;
    supply: BigNumberish;
}
export interface TokenERC1155AlreadyMintedArgs {
    tokenId: BigNumberish;
    amount: BigNumberish;
}
/**
 * Create a collection of NFTs that lets you optionally mint multiple copies of each NFT.
 *
 * @example
 *
 * ```javascript
 * import { ThirdwebSDK } from "@3rdweb/sdk";
 *
 * // You can switch out this provider with any wallet or provider setup you like.
 * const provider = ethers.Wallet.createRandom();
 * const sdk = new ThirdwebSDK(provider);
 * const module = sdk.getBundleModule("{{module_address}}");
 * ```
 *
 * @public
 */
export declare class SignatureMint1155Module extends ModuleWithRoles<SignatureMint1155> implements ITransferable {
    static moduleType: ModuleType;
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    /**
     * @override
     * @internal
     */
    protected getModuleRoles(): readonly Role[];
    /**
     * @internal
     */
    protected connectContract(): SignatureMint1155;
    /**
     * @internal
     */
    protected getModuleType(): ModuleType;
    /**
     *
     * Get a single bundle item by tokenId.
     * @param tokenId - the unique token id of the nft
     * @returns A promise that resolves to a `BundleMetadata`.
     */
    get(tokenId: string, address?: string): Promise<TokenERC1155Metadata>;
    /**
     * Get NFT Data
     *
     * @remarks Get data associated with NFTs in this module.
     *
     * @example
     * ```javascript
     * // You can get every NFT in the module
     * const nfts = await module.getAll();
     * console.log(nfts);
     *
     * // Or you can get optionally get the NFTs owned by a specific wallet
     * const address = "{{wallet_address}}"; // The address you want to get the NFTs for;
     * const ownedNfts = await module.getAll(address);
     * console.log(ownedNfts);
     * ```
     *
     * @returns The NFT metadata for all NFTs in the module.
     */
    getAll(address?: string): Promise<TokenERC1155Metadata[]>;
    /**
     * Get NFT Balance
     *
     * @remarks Get a wallets NFT balance (number of a specific NFT in this module owned by the wallet).
     *
     * @example
     * ```javascript
     * // Address of the wallet to check NFT balance
     * const address = "{{wallet_address}}";
     * // The token ID of the NFT you want to check the wallets balance of
     * const tokenId = "0"
     *
     * const balance = await module.balanceOf(address, tokenId);
     * console.log(balance);
     * ```
     */
    balanceOf(address: string, tokenId: string): Promise<BigNumber>;
    balance(tokenId: string): Promise<BigNumber>;
    isApproved(address: string, operator: string, assetContract?: string, assetId?: BigNumberish): Promise<boolean>;
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    /**
     * Transfer NFT
     *
     * @remarks Transfer an NFT from the connected wallet to another wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to send the NFT to
     * const toAddress = "0x...";
     *
     * // The token ID of the NFT you want to send
     * const tokenId = "0";
     *
     * // The number of NFTs you want to send
     * const amount = 1;
     *
     * await module.transfer(toAddress, tokenId, amount);
     * ```
     */
    transfer(to: string, tokenId: string, amount: BigNumberish): Promise<TransactionReceipt>;
    createAndMint(args: TokenERC1155CreateAndMintArgs): Promise<void>;
    createAndMintTo(to: string, args: TokenERC1155CreateAndMintArgs): Promise<void>;
    createAndMintBatch(args: TokenERC1155CreateAndMintArgs[]): Promise<void>;
    createAndMintBatchTo(to: string, args: TokenERC1155CreateAndMintArgs[]): Promise<void>;
    mintAdditionalCopiesTo(to: string, args: TokenERC1155AlreadyMintedArgs): Promise<void>;
    mintAdditionalCopiesBatchTo(to: string, args: TokenERC1155AlreadyMintedArgs[]): Promise<void>;
    /**
     * Burn NFT
     *
     * @remarks Burn an NFT, permanently taking it out of circulation and reducing the supply.
     *
     * @example
     * ```javascript
     * // The token ID of the NFT you want to burn
     * const tokenId = 0;
     * // The number of specified NFTs you want to burn
     * const amount = 1
     *
     * await module.burn({ tokenId, amount });
     * ```
     */
    burn(args: TokenERC1155AlreadyMintedArgs): Promise<TransactionReceipt>;
    burnBatch(args: TokenERC1155AlreadyMintedArgs[]): Promise<TransactionReceipt>;
    burnFrom(account: string, args: TokenERC1155AlreadyMintedArgs): Promise<TransactionReceipt>;
    burnBatchFrom(account: string, args: TokenERC1155AlreadyMintedArgs[]): Promise<TransactionReceipt>;
    transferFrom(from: string, to: string, args: TokenERC1155AlreadyMintedArgs, data?: BytesLike): Promise<TransactionReceipt>;
    /**
     * Transfer Many NFTs
     *
     * @remarks Transfer NFTs from the one wallet to another.
     *
     * @example
     * ```javascript
     * // Address of the wallet to send the NFT from
     * const fromAddress = "{{wallet_address}}";
     * // Address of the wallet you want to send the NFT to
     * const toAddress = "0x...";
     *
     * // The data of the NFTs you want to send
     * const data = [{
     *   tokenId: 1, // The token ID of the NFT you want to send
     *   amount: 1, // The number of this NFT you want to send
     * }, {
     *   tokenId: 2,
     *   amount: 1,
     * }]
     *
     * // Note that the connected wallet must have approval to transfer the tokens of the fromAddress
     * await module.transferBatchFrom(fromAddress, toAddress, data);
     * ```
     */
    transferBatchFrom(from: string, to: string, args: TokenERC1155AlreadyMintedArgs[], data?: BytesLike): Promise<TransactionReceipt>;
    /**
     * Set the royalty recipient and fee for this contract
     * @param recipientAddress
     * @param fee
     */
    setDefaultRoyaltyInfo(recipientAddress: string, fee: number): Promise<TransactionReceipt>;
    /**
     * Set the royalty recipient and fee for a particular token
     * @param recipientAddress
     * @param fee
     */
    setTokenRoyaltyInfo(tokenId: BigNumberish, recipientAddress: string, fee: number): Promise<TransactionReceipt>;
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    /**
     * `getOwned` is a convenience method for getting all owned tokens
     * for a particular wallet.
     *
     * @param _address - The address to check for token ownership
     * @returns An array of BundleMetadata objects that are owned by the address
     */
    getOwned(_address?: string): Promise<TokenERC1155Metadata[]>;
    /**
     * Gets the royalty recipient and BPS (basis points) of the contract
     *
     * @returns - The royalty recipient and BPS
     */
    getDefaultRoyaltyInfo(): Promise<[string, number]>;
    /**
     * Gets the royalty recipient and BPS (basis points) of a particular token
     *
     * @returns - The royalty recipient and BPS
     */
    getTokenRoyaltyInfo(tokenId: BigNumberish): Promise<[string, number]>;
    isTransferRestricted(): Promise<boolean>;
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    mintWithSignature(req: Erc1155SignaturePayload, signature: string): Promise<BigNumber>;
    verify(mintRequest: Erc1155SignaturePayload, signature: string): Promise<boolean>;
    generateSignatureBatch(payloads: NewErc1155SignaturePayload[]): Promise<{
        payload: Erc1155SignaturePayload;
        signature: string;
    }[]>;
    generateSignature(mintRequest: NewErc1155SignaturePayload): Promise<{
        payload: Erc1155SignaturePayload;
        signature: string;
    }>;
    /**
     * Maps a payload to the format expected by the contract
     *
     * @internal
     *
     * @param mintRequest - The payload to map.
     * @returns - The mapped payload.
     */
    private mapPayload;
    private setAllowance;
}
